INTRO
Voici la définition de ce qu’on voudrait :
Choix entre plusieurs véhicules (choix de 3 véhicules prédéfinis ou d’1 4ème véhicule dont on définit les dimensions au moment du calcul
Paramètres à tenir en compte pour le calcul :
Dimensions du véhicule
Poids des colis
Dimensions des colis
Possibilité de gerber les colis (en fonction du poids ou de notre choix) et en fonction des dimensions des colis en dessous (notion de colis supérieur « dépassant » le colis inférieur)
Possibilité de ranger les colis selon une autre dimension (les « retourner »)
Ordre de chargement et de déchargement.

CHOIX LANGUAGE
  python ou c++
    -backtracking
        -python:plus simple             +
        -c++:plus compliqué             -
    -librairie 3D (probablement)
        -python:?                           -
        -c++:sûr                            +
    -structure de données souples   
        -python:plus souple(et plus lisibles)       +
        -c++:chargé                                 -
    -rapiditée
        -python:moins rapide        -
        -c++:plus rapide            +
    -natif
        -python:non         -
        -c++:oui            +

->C++


Compilation:
    compiler sous windows quand : (console->gui, 3D, à la fin)
    compilation linux : -g++ via script (jusqu'à fin du noyaux)
                        -selon compilateur windows

    compilation windows : -quel pc?
                          -quel compilateur?
    
    Librairies : -wxWidget (linux+windows)
                 -opengl (linux+windows)

CAHIER DES CHARGES :
    Remplissage d'une boite englobante par boite pour optimiser volume
        Partie I Coeur          x
            -Boite              x
            -Vecteurs           x
            -Algorithmes            x
                -collision 3D AABB              x
                -rotations // axes centrer sur centre géométrique  (swaps de coordonnées)   -x
                -équilibre 3D           x
                    -surface de contact         x
                -répartition des poids              x
            -Taille boite englobante variable       x
            -Taille autres boites variable          x
            -rotation // x,y,z sur centre de masse si uniformément réparti de (90|180|270)°     !!
            -poid           x
        Partie II contraintes
            -dépassement de colis (équilibre statique de 2 boîtes + marge car non-réaliste)     x
            -ordre de chargement imposé (ordre strict de calcul(démarre du fond))               x
            -précision(déplacement dx + collision boite alignée (AABB))                         x
            -peut-ere tournée (dans quel sens)                                                  x
            -peut-être gerbée (poid au dessus/en-dessous)                                       x
        Partie III algorithme proprement dit
            Utiliser branch & bound
            -filtres de qualité             x
            -structure arborescente
            -ajout branch structure arborescente
            -ajout bound structure arborescente
            -ajout prune structure arborescente
            -écriture boucle de backtracking
            -callback pour mettre vue à jour lors du calcul
        Partie IV Interface-vue
            -création d'espace à remplir
            -création d'objets pour remplir les espaces
            -paramètrages algorithme
            -résultat
                -2D pour test (face&&droite&&dessus)
                -3D pour final
            -consultation données
        Partie V Interface-controleur
            -modification données
            -modification vue
            -gestion animation
            -déroulement du programme

ALGORITHME collision AABB 3D:   //repère dans un coin du cube
    Recevoir en entrée box1 et box2 à tester
    si box2.x >= box1.x+box1.w
    ou
    si box2.x + box2.w <= box1.x
    ou
    si box2.y >= box1.y + box1.h            une collision par face
    ou
    si box2.y + box2.h <= box1.y
    ou
    si box2.z >= box1.z + box1.d
    ou
    si box2.z + box2.d <= box1.z
        
        Il n'y a pas collision
    sinnon
        il y a collision

ALGORITHME rotations//axes (3D):
    Recevoir en entrée (X|Y|Z, theta)
    tant que pas theta < 360:
        theta /= 90
    si pas theta%90 == 0:
        theta -= theta%90
    //0 < theta < 360 && theta%90==0
    Si Z :      
        si theta==90 || theta==270
            échanger dimensions x,y
    Si Y : 
        si theta==90 || theta==270
            échanger dimesions x,z
    Si X :
        si theta==90 || theta==270
            échanger dimesions y,z

ALGORITHME EQUILIBRE:
    Division surface inférieure de la box en m*n petites surface ds,
    pour chaque ds, si elle repose sur un autre colis ou sur le sol : +1
    si le compteur atteint (m*n)/2 : true, sinnon : false
    //algo implémenté cf : SpaceToFill::isStable

HEURISTIQUE backtracking :
    Aucun coli n'est écrasé && Touts colis en équilibre && maximum de colis && maximum de colis au contact && maximum de volume au contact && meilleure boite arrière
    représenté par la fonction SpaceToFill::getQuality

ALGORITHME backtracking :
    classique branch and bound, sur base de structure arborescente
    pour bound : SpaceToFill::getQuality

complexité:
    x : boites à agencer
    y : nb espaces de travail
    p : precision
    v(y) : volume espace y
    c(O) = y*x*(v(y))/precision
    grosse majorations:
        x == y² (très petites caisses ou très grand camion)
        c(O) = y³*(v(y))
    approximation : 
        x >> y
        donc y == x (dans ce sens) majorant
        c(O) = x²*(v(y))
        test réaliste : 
            35 boites
            1 camion
            volume : 15m³
            précision : 1cm
            c = 35*1*15/0.001 = 525 000 iter
            pour 2 camions = 1 050 000 iter
       

CHOIXS---------------------------------------:
    -python ou c++ : C++
    -cross compiling ou portage : ?
!    -ordre de chargement : section de l'espace ou ordre fixe
!    -2D indispensable?
repère


STRUCTURES DE DONNEES:
    PARTIE I+II Core+contraintes
    Vect2D : struct, vecteur (x,y,z) (uInt,uInt,uInt)
    Box : class couche abstraite pour boite englobante ou non un objet
          attr:
            -uInt id : identifiant de la boite (par rapport à ce qu'elle contient spécial:SpaceToFill=0)
            -Vect3D dim : dimension(dim//x, dim//y, dim//z)
            -Vect3D centre : centre de la boite(x,y,z)
            -uInt weight : poid en grammes
          méth:
            -virtual void rotate(X|Y|Z) : effectue une rotation de 90° sur X|Y|Z de la box
            -virtual bool : collide(Box* one) : renvoie true si les boites sont en collisions(AABB)
            -static bool : isBoxInside(Box* mayInside, Box* mayOutside) = renvoie true si mayInside dans mayOutside
            -static bool : isPointInside(vect3D point, Box* thBox)
            -void move(Vect3D displacement) : déplace la boite des  quantitées indiquées 
            -uInt getVol() : renvoie le volume (dim.x*dim.y*dim.z)
            -uInt getWeight() : renvoie le poids
            -Vect3D* getDim()
            -Vect3D* getCenter()

    ObjectBox(box) : class, boite englobant un objet
          attr:
            -List(box*) boxList : liste des boxes constituant l'objet
            -bool canMove : ""
            -bool canBeToped : ""
            -uInt maxWeightOnTop
            -bool canBeBottomed
            -bool canBeRotated[AXIS] : booléen pour chaque axes
            -bool isSingleBox : booléen car différents cas
          méth:
            -uInt getListLen() : renvoie la longueur de la liste de box
            -box* getBoxNb(uInt nb) : renvoie la boxe à l'indice nb, vérification de l'indice : 0 <= nb <len(list)
            -virtual bool collide(Box* one) : test collision par rapport aux sous-boite
            -accesseur pour propriétes
            
    SpaceToFill(box) : class, espace à remplir, il faut lui demander si une boite peut s'insérer
                  modèle intérieur en collection de boites internes
                  attr:
                    -Stack(Box*) boxStack : stack de boites uInternes(pour faciliter backtracking et dérécursification)
                    -Double volLeft : volume libre(stocké)
                    -Double precision : précision (à définir)                                                   /!\
                  méth:
                    -virtual bool collide(Box* one)
                    -bool isEmpty() : renvoie true si l'espace est vide
                    -uInt getVolLeft() : renvoie volume libre (uInt) (volLeft)
                    -uInt getStackLen() : renvoie la taille du stack (uInt)  (nombre de boites internes)
                    -bool isInternable(objectBox* box) : renvoie true/false si boîte correctement positionnée
                        -bool isStable(Box* box) : cf algorithme d'équilibre
                        -bool isCompatible(Box* box) : test ordre de chargement et peut-être soulevé et il peut-y avoir quelque chose au dessus cf cahier des charges
                    -void uIntern(objectBox* box) : push la boite sur le stack /!\ ne fait pas de test            /!\
                    -void empty() : vide le stack
                    -objectBox* pop() : renvoie la dernière boite à avoir été insérée
                    -void setPrecision(Double newPrecision) : remplace la precision par newPrecision, non-rétroactif
                    -Stack(objectBox*) getBoxStack() : renvoie le stack de l'espace(pour afficher)
                    -uInt getDensity() : renvoie la somme de la somme du volume de chaque boites et de chaques boites en contact pour toutes les boites
                    -Vect3D getLargestBoxBehind() : renvoie la taille sur la profondeur de libre d'une section arrière
                    -Vect3D getCenterOfMass() : centre de masse de l'ensemble des boites, la distance entre ce point et le centre géométrique = heuristique

    III : Algorithme (principal)
    SemiSol : struct, réuni list de SpaceToFill* et de ObjectBox*
            .spaces : std::vector<SpaceToFill*>;
            .objectsLefts : std::vector<ObjectBox*>;

    BandBTree : class, structure arborescente incluant une configuration ainsi que des sous-configurations
            attr:
                static long int highestLowBound = 0;
                bool hasBranched = false;
                std::vector<ObjectBox*> toFitIn;    //pas encore inséré
                std::vector<SpaceToFill*> toFill;   //déjà inséré
                std::vector<BandBTree*> sons;
                std::vector<long int> bounds;
            meth:
                void branch();
                void bound();
                void prune();
                uInt getsonsLength();
                BandBTree* getSonNb(uInt nb);   //peut renvoyer null
                getHasBranched();
                ~BandBTree();

    /*Parcour à déterminer*/

    IV : Vues
        -Acceuil
        -visu configuration recherche (avant recherche de solution)
            -véhicule
                -taille
                -aperçu
            -boites
                -tailles(x,y,z)
                -fixe (y/n)
                -peut-être écrasée(y/n)
                -peut-être soulevée(y/n)
                -poid(y/n)
                -rotations possibles (x,y,z) (y/n)
            -aperçu boite
        -visualisation solution
            -plusieurs solutions
            -animation des solutions
            -échelles
            -repère
            -identification des boites
        -options

    V : Controleur
        -Acceuil
            -quitter
            -vers configuration recherche
        -configuration de recherche
            -contrôle véhicule
                -tailles(x,y,z)
            -contrôle boites
                -ajouter-boite (objet)
                    -ajouter-boite
                        -tailles(x,y,z)
                        -fixe (y/n)
                        -peut-être écrasée(y/n)
                        -peut-être soulevée(y/n)
                        -poid(y/n)
                        -rotations possibles (x,y,z) (y/n)
            -contrôle critère de recherche
                -Plus Dense || plus d'espace restant à l'arrière-x || poid + réparti (filtres)
                -nb de solution max à présenter
                -precision
            -quitter
            -vers visualisation solution
        -visualisation solutions
            -choix solution
            -contrôle de l'animation (play-pause or next/previous)
            -contrôle de l'echelle (zoom sur centre)
            -trackball (rotations) (contrôle du repère)
            -nouvelle recherche
            -quitter


Estimation temps necessaire pour effectuer toutes les opérations :
        Au fûr et à mesure que l'on descend dans l'arbre, plus d'ObjectBox sont placés
        chaque embranchement désigne un véhicule et une position

